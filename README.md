# Open Philosophy Faculty. System Design.

## **Step 1: Требования**

- В системе существуют три вида пользователей: студенты, преподаватели и админ.
- У студентов, преподавателей и админа – разные возможности.
- Курсы могут создавать преподаватели и админ.
- Курсы могут содержать тексты, фотографии, аудиозаписи и видеозаписи.
- Мы проектируем фронтенд и бекенд.
- Для фронтенда мы проектируем как мобильную версию, так и десктоп.
- Пользователи могут искать курсы на сайте.
- Могут ли студенты оставлять вопросы/комментировать/давать обратную связь по курсу/уроку?

## **Step 2: Предварительная оценка**

Всегда полезно оценить масштаб системы, которую мы собираемся разработать. Это также поможет позже, когда мы сосредоточимся на масштабировании, разделении, балансировке нагрузки и кэшировании.

- Какой масштаб ожидается от системы:
    - Количество курсов — до 500
    - Количество просмотров курсов — до 500000
    - Количество пользователей — до 500000
- Сколько памяти нам понадобится? У нас будут разные требования к хранилищу, если курсы содержат фотографии и видео.
- Какое использование пропускной способности сети мы ожидаем? Это будет иметь решающее значение при принятии решения о том, как мы будем управлять трафиком и балансировать нагрузку между серверами.

## **Step 3: Определение системного интерфейса**

Определите, какие API ожидаются от системы. Это установит точный контракт, ожидаемый от системы, и гарантирует, что мы не ошиблись в каких-либо требованиях. Ниже приведены некоторые примеры API для нашего сервиса:

```
createCourse(author_ids, course_title, course_definition, course_lectures, additional_materials, offline_data, ...)
```

```
generateFeed(user_id, …)
```

```
markCourseFavorite(user_id, course_id, timestamp, …)

```

## **Step 4: Определение модели данных**

Определение модели данных позволит выяснить, как данные будут передаваться между различными компонентами системы. Позже он поможет нам разделить данные и управлять ими. 

Мы должны определить различные системные сущности, то, как они будут взаимодействовать друг с другом, а также различные аспекты управления данными, такие как хранение, транспортировка, шифрование и т. д. Вот некоторые сущности для нашего сервиса:

**Пользователь:** Идентификатор пользователя, имя, адрес электронной почты, дата рождения, дата создания, последний вход и т. д. 

**Курс:** Идентификатор курса, описание, название, количество лайков, время создания, время проведения, видео-контент, картинки, уроки, и т. д. 

**Урок**: Идентификатор урока, описание, название, количество лайков, время создания, время проведения, видео-контент, картинки, и т. д. 

**Избранные курсы :** Идентификатор пользователя, идентификатор курса, время создания

Какую систему баз данных мы должны использовать? Будет ли NoSQL, как [Cassandra](https://en.wikipedia.org/wiki/Apache_Cassandra), наилучшим образом соответствовать нашим потребностям, или нам следует использовать решение, подобное MySQL? Для большинства данных подходит SQL-решение.

Какое хранилище мы должны использовать для хранения фотографий и видео? Здесь больше подходит NoSQL — MongoDB, Cassandra.

## **Step 5: Высокоуровнеый дизайн**

Нарисуем блок-схему с 5-6 блоками, представляющими основные компоненты нашей системы. Мы должны определить достаточное количество компонентов, необходимых для полного решения актуальной проблемы.

[https://miro.com/app/board/uXjVOIMJrPM=/?share_link_id=259435452506](https://miro.com/app/board/uXjVOIMJrPM=/?share_link_id=259435452506)

На высоком уровне нам потребуется несколько серверов приложения для обслуживания всех запросов на чтение/запись с балансировщиками нагрузки перед ними для распределения трафика. Если мы предполагаем, что у нас будет намного больше трафика на чтения (по сравнению с записью), мы можем решить иметь отдельные серверы для обработки этих сценариев. На бэкенде нам нужна эффективная база данных, которая может хранить все курсы и поддерживать большое количество чтений. Также нам понадобится распределенная файловая система хранения для хранения фото и видео.

## **Step 6: Детальный дизайн**

Мы должны представить различные подходы, их плюсы и минусы и объяснить, почему мы предпочтем один подход другому. Важным является рассмотрение компромиссов между различными вариантами, не забывая при этом о системных ограничениях.

- Поскольку мы будем хранить огромное количество данных, как мы должны разделить наши данные, чтобы распределить их по нескольким базам данных? Должны ли мы пытаться хранить все данные пользователя в одной базе данных? Какую проблему это может вызвать?
- Как мы будем обращаться с горячими пользователями, которые много комментируют, сохраняют и просматривают курсы?
- Сколько и на каком уровне мы должны ввести кеш, чтобы ускорить работу?
- Какие компоненты нуждаются в лучшей балансировке нагрузки?

## **Step 7: Обнаружение и устранение узких мест**

Постарайтесь обсудить как можно больше узких мест и различные подходы к их устранению.

- Есть ли в нашей системе единая точка отказа? Что мы сделаем, чтобы избавиться от нее?
- Достаточно ли у нас реплик данных, чтобы мы могли обслуживать наших пользователей, даже если мы потеряем несколько серверов?
- Аналогично, достаточно ли у нас копий различных запущенных служб, чтобы несколько сбоев не привели к полному отключению системы?
- Как мы следим за работой нашего сервиса? Получаем ли мы оповещения всякий раз, когда критические компоненты выходят из строя или их производительность снижается? Какие системы мониторинга используем?
